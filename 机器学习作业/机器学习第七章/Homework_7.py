import math

# 定义数据集
dataSet = [
    ['青绿', '蜷缩', '浊响', '清晰', '凹陷', '硬滑', 0.697, 0.460, 1],
    ['乌黑', '蜷缩', '沉闷', '清晰', '凹陷', '硬滑', 0.774, 0.376, 1],
    ['乌黑', '蜷缩', '浊响', '清晰', '凹陷', '硬滑', 0.634, 0.264, 1],
    ['青绿', '蜷缩', '沉闷', '清晰', '凹陷', '硬滑', 0.608, 0.318, 1],
    ['浅白', '蜷缩', '浊响', '清晰', '凹陷', '硬滑', 0.556, 0.215, 1],
    ['青绿', '稍蜷', '浊响', '清晰', '稍凹', '软粘', 0.403, 0.237, 1],
    ['乌黑', '稍蜷', '浊响', '稍糊', '稍凹', '软粘', 0.481, 0.149, 1],
    ['乌黑', '稍蜷', '浊响', '清晰', '稍凹', '硬滑', 0.437, 0.211, 1],
    ['乌黑', '稍蜷', '沉闷', '稍糊', '稍凹', '硬滑', 0.666, 0.091, 0],
    ['青绿', '硬挺', '清脆', '清晰', '平坦', '软粘', 0.243, 0.267, 0],
    ['浅白', '硬挺', '清脆', '模糊', '平坦', '硬滑', 0.245, 0.057, 0],
    ['浅白', '蜷缩', '浊响', '模糊', '平坦', '软粘', 0.343, 0.099, 0],
    ['青绿', '稍蜷', '浊响', '稍糊', '凹陷', '硬滑', 0.639, 0.161, 0],
    ['浅白', '稍蜷', '沉闷', '稍糊', '凹陷', '硬滑', 0.657, 0.198, 0],
    ['乌黑', '稍蜷', '浊响', '清晰', '稍凹', '软粘', 0.360, 0.370, 0],
    ['浅白', '蜷缩', '浊响', '模糊', '平坦', '硬滑', 0.593, 0.042, 0],
    ['青绿', '蜷缩', '沉闷', '稍糊', '稍凹', '硬滑', 0.719, 0.103, 0]
]
# 求每种特征的属性个数
uiq = []
temp = []
for j in range(6):
    for i in range(len(dataSet)):
        temp.append(dataSet[i][j])
        temp = list(set(temp))
    uiq.append(len(temp))


# 对连续属性考虑概率密度函数
def density_1(x):
    return 3.092624 * math.exp(-(((x - 0.574) ** 2) / 0.033282))


def density_0(x):
    return 2.045857 * math.exp(-(((x - 0.496) ** 2) / 0.07605))


def sugar_1(x):
    return 3.949923 * math.exp(-(((x - 0.279) ** 2) / 0.020402))


def sugar_0(x):
    return 3.693910 * math.exp(-(((x - 0.154) ** 2) / 0.023328))


# 带拉普拉斯修正的朴素贝叶斯分类器
def naive_bayes(test):
    # 将 好瓜 与 坏瓜 分开
    GW = []
    BW = []
    for i in range(len(dataSet)):
        if dataSet[i][8] == 1:
            GW.append(dataSet[i])
        else:
            BW.append(dataSet[i])
    # 初始化好瓜与坏瓜的概率
    pg = 1.0
    pb = 1.0

    # 估计类先验概率
    P_D1 = len(GW) / len(dataSet)
    P_D0 = len(BW) / len(dataSet)

    # 为每个属性估计条件概率
    for j in range(6):
        n1 = 0.0
        n0 = 0.0
        for k in range(len(GW)):
            if GW[k][j] == test[j]:
                n1 = n1 + 1.0
        pg = pg * ((n1 + 1.0) / (len(GW) + uiq[j]))

        for k in range(len(BW)):
            if BW[k][j] == test[j]:
                n0 = n0 + 1.0
        pb = pb * ((n0 + 1.0) / (len(BW) + uiq[j]))

    pg = P_D1 * density_1(test[6]) * sugar_1(test[7])
    pb = P_D0 * density_0(test[6]) * sugar_0(test[7])

    print("判为好瓜的概率:", pg)
    print("判为坏瓜的概率:", pb)
    result = "好瓜" if pg > pb else "坏瓜"
    print("结果为:", result)


if __name__ == '__main__':
    test = ['青绿', '蜷缩', '浊响', '清晰', '凹陷', '硬滑', 0.697, 0.460]
    naive_bayes(test)
